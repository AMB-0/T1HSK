

%----------------------------------------------------------------------------------------
% 			I. PREFACE AREA OF THE DOCUMENT
%----------------------------------------------------------------------------------------

\documentclass[12p]{report}

\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[procnames]{listings}
\usepackage{color}

%----------------------------------------------------------------------------------------
% 			 II.  BEGIN OF THE DOCUMENT
%----------------------------------------------------------------------------------------


\begin{document}


%----------------------------------------------------------------------------------------
%			  PAGE 1 : TITLE PAGE
%----------------------------------------------------------------------------------------

\begin{titlepage}

\pagenumbering{gobble}		% Delete the page number for the title page

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
%----------------------------------------------------------------------------------------
%			Heading Section of the title
%----------------------------------------------------------------------------------------

\textsc{\Huge University of Helsinki}\\[2cm] % Name of your university/college
\textsc{\LARGE Computer Science Department}\\[0.5cm] % Major heading such as course name

%----------------------------------------------------------------------------------------
%				Title section
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \Huge \bfseries PreAssignment 2016}\\[0.4cm] % Set the title of the document
\HRule \\[2.5cm]
 

%----------------------------------------------------------------------------------------
%				Author Section
%----------------------------------------------------------------------------------------

% If you don't want a supervisor, uncomment the two lines below and remove the section above
\LARGE \emph{Author:}\\
\LARGE Andres Medina\\[0.05cm] % Your name
\textsc{\Large (UAF 1608168)}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%				Date Section
%----------------------------------------------------------------------------------------

{\LARGE \today}\\[3cm] % Date, change the \today to a set date if you want to be precise

 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}


%----------------------------------------------------------------------------------------
%				END OF THE TITLE PAGE
%----------------------------------------------------------------------------------------


  \newpage 				% Creates a new page


%----------------------------------------------------------------------------------------
%				PAGE 2:  	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

  \tableofcontents 			% Creates the table of contents page



  \newpage 				% Creates a new page


%----------------------------------------------------------------------------------------
%				PAGE 3:  	TASK 1
%----------------------------------------------------------------------------------------


  \pagenumbering{arabic}		% Restores the page number (could also be used with roman for roman numbers)


%----------------------------------------------------------------------------------------
%				Title section
%----------------------------------------------------------------------------------------

  \chapter{Preassignment - Task 1}			% Subsection of a document

%----------------------------------------------------------------------------------------
%				(1) First section
%----------------------------------------------------------------------------------------
 
  \section{Introduction}			% Subsection of a document

%   First Paragraph
  \large The first task of the preassignment consists in experimentally test that the amortized complexity of $(n-1)$ calls to \textbf {inorder\_next} in a binary tree is $2(x-1)$.

\bigskip

%   Second Paragraph
 \large To achieve this task, the following strategy was followed:

\begin{enumerate}

  \item First, we created a program that generates random Binary Trees. This allows us to had a test set in which we prove the current hypothesis.
  \item After creating the random Binary Tree generator, we create a second program that allows us to transverse the binary tree in inorder \textit{(inorder means, first visiting the left node, then the root and finally the right node)}. The program also returns the amount of steps involved in this operation.
  \item By using both programs, we made a table that compare the amount of steps taken to transverse every binary tree in comparison with the number of nodes of each tree.
  \item Finally, we made a plot with the data of the table and by using linear regression, we get the equation corresponding to that line plot. We expect that the slope of that line plot should be something bigger or equal to $2(x-1)$ \textit{(it should be bigger or equal because the amortized complexity correspond to an upper bound of the actual complexity of an algorithm)}.

\bigskip

The results obtained in the analysis are described in the results section of this paper.

\end{enumerate}


%----------------------------------------------------------------------------------------
%				(2) Second section
%----------------------------------------------------------------------------------------

  \section{Materials and Methods}
In this section, we will describe the tools and the logic used to solve every single step that composed the task 1 of this preassignment. This section include topics like the programming framework used to solve this task and also what was the logic applied to develop those programs.


%----------------------------------------------------------------------------------------
%				(2.1) First Subsection
%----------------------------------------------------------------------------------------

  \subsection{Programming Tools}
For developing the required programs we choose to use the following tools:

\begin{itemize}
  \item Python 3.5.1 as the programming language
  \item Github as a repository tool
  \item Sublime Text as the code editor
\end{itemize}

In addition, the random library of python was used for accomplish the tasks related with randomness.


%----------------------------------------------------------------------------------------
%				(2.2) Second Subsection
%----------------------------------------------------------------------------------------

  \subsection{Programming Logic}
The two programs involved in this task were programmed by using OOP paradigm.
Considering the fact that the task 1 of the preassignment involves the creation of two different programs, we choose to explain the logic of each program in a different subsection. 


  \subsubsection{Creating a Random Binary Tree}

The creation of the binary tree was implemented by developing two different classes: a binary node class and a binary tree class. The binary node class contains 3 different attributes, an Id, a reference to a left child node and a reference to a right child node while the binary tree class contains only two attributes, a list of binary nodes and the total cost of traversing the tree in inorder. By using this two classes, creating a random binary tree was possible. Also when every binary tree is created, a random tree setting method is called so that every tree created has a different and also random structure.

\bigskip

The random tree setting method work as follows: 
\begin{itemize}
  \item First, a  integer number between 50 and 100 is choose randomly. This number will represent the number of nodes of the corresponding binary tree
  \item Second, a left-right flag is set by choosing a random integer number between 0 and 1
  \item Then, after the left-right flag is set, a random node of the tree is chosen. Only the nodes that doesn't already have the corresponding child are candidates for this random choice. \textit{For example, if the left-right flag is set to left, only nodes that doesn't have left childs are possible candidates of this random choice. Conversely, if the left-right flag is set to right, only nodes that doesn't have right childs are possible candidates}
  \item Finally, the corresponding child is created in the randomly chosen node of the tree
\end{itemize}

The described logic repeats until the number of nodes of the binary tree is reached.

  \subsubsection{Traversing a Binary Tree in inorder}
The traversing of a binary tree in inorder can be made mainly in two different ways: by using recursion and by not using recursion. In this case, we choose to implement this method using recursion as this method allow to achieve a smaller and cleaner code and also allow us to avoid the implementation of a link between a child node and it's parent node.

\bigskip

The idea of this implementation is mainly the following:
\begin{itemize}
  \item We start by applying this method to the root node of the tree
  \item If the root node has a left child, then we call again the traverse\_inorder method but this time we pass the left child node as an argument to the method
  \item When the corresponding node has no left child node, then we ask if the node has a right child. If the node has a right child, then we call again the traverse\_inorder method but this time we pass the right child node as an argument to the method
  \item After no more left and right child are found, the traverse\_inorder method returns. Of course we should consider a logic for counting the corresponding steps in each call of the method so that when the method ends, we have the total amount of steps already calculated.
\end{itemize}

In the next section we will show and analyze the results of the above implementations.

%----------------------------------------------------------------------------------------
%				(3) Third section
%----------------------------------------------------------------------------------------

  \section{Results}
When the two generated programs are run, an output table is created. This table includes three columns:
\begin{enumerate}
  \item \textbf{Binary Tree ID } Represents the Id of the binary tree
  \item \textbf{Number of nodes of the Tree } Represents the number of nodes of the binary tree 
  \item \textbf{Total steps of inorder traverse } Represents the amounts of steps involved in the inorder traverse operation
\end{enumerate}

The results obtained in this computation are shown in the following table:

%----------------------------------------------------------------------------------------
%				Table section
%----------------------------------------------------------------------------------------

\footnotesize
\begin{table}[ht]
\caption{Binary Tree traverse results using 50 different trees}	% title of Table
%\centering 									% used for centering table
\begin{tabular}{c c c} 							% centered columns (3 columns)
\hline\hline 									%inserts double horizontal lines
Tree Id & Number of Nodes & Total Steps\\ [0.5ex] 			% inserts table
%heading
\hline % inserts single horizontal line
1 & 83 & 164 \\ 								% inserting body of the table
2 & 94 & 186 \\
3 & 69 & 136 \\
4 & 99 & 196 \\
5 & 53 & 104 \\
6 & 63 & 124 \\
7 & 72 & 142 \\
8 & 61 & 120 \\
9 & 55 & 108 \\
10 & 90 & 178 \\
11 & 81 & 160 \\
12 & 74 & 146 \\
13 & 92 & 182 \\
14 & 85 & 168 \\
15 & 75 & 148 \\
16 & 66 & 130 \\
17 & 95 & 188 \\
18 & 64 & 126 \\
19 & 71 & 140 \\
20 & 95 & 188 \\
21 & 52 & 102 \\
22 & 77 & 152 \\
23 & 53 & 104 \\
24 & 84 & 166 \\
25 & 80 & 158 \\
\hline %inserts single line
\end{tabular}
\qquad
%\centering 									% used for centering table
\begin{tabular}{c c c} 							% centered columns (3 columns)
\hline\hline 									%inserts double horizontal lines
Tree Id & Number of Nodes & Total Steps\\ [0.5ex] 			% inserts table
%heading
\hline % inserts single horizontal line
26 & 70 & 138 \\
27 & 95 & 188 \\
28 & 68 & 134 \\
29 & 88 & 174 \\
30 & 98 & 194 \\
31 & 99 & 196 \\
32 & 63 & 124 \\
33 & 66 & 130 \\
34 & 59 & 116 \\
35 & 94 & 186 \\
36 & 85 & 168 \\
37 & 59 & 116 \\
38 & 68 & 134 \\
39 & 93 & 184 \\
40 & 62 & 122 \\
41 & 75 & 148 \\
42 & 100 & 198 \\
43 & 92 & 182 \\
44 & 82 & 162 \\
45 & 84 & 166 \\
46 & 58 & 114 \\
47 & 63 & 124 \\
48 & 69 & 136 \\
49 & 51 & 100 \\
50 & 66 & 130 \\ 
\hline %inserts single line
\end{tabular}

\label{table:nonlin} % is used to refer this table in the text
\end{table}

  \newpage 				% Creates a new page

\large By inspecting the results of the table we can clearly see that the amount of steps that takes to traverse a binary tree, directly depends of the amount of nodes that compose that particular binary tree. 

\bigskip

To obtain the equation that describes the relation between the number of nodes and the amount of steps that takes to traverse a binary tree, we decided to plot the data in the table shown previously and use linear regression to obtain the equation. The result of this linear plot is shown in the following image:

%----------------------------------------------------------------------------------------
%				Graph section
%----------------------------------------------------------------------------------------

\includegraphics{Graph2}

As we can see, the value of the \textbf{coefficient of determination} also know as $R^2$ is 1. This means that the linear regression line perfectly fits the plotted data. The equation that describes this relation is correspond to $y=2x-2$ where $x$ represents the number of nodes in a binary tree and $y$ represents the amounts of steps that takes to traverse that particular tree in inorder.

\bigskip

We will discuss the meaning of this result in the next section of the text.

%----------------------------------------------------------------------------------------
%				(4) Forth section
%----------------------------------------------------------------------------------------

  \section{Discussion}

As we saw in the last section, the amount of steps that takes to traverse a random binary tree in inorder is $2x-2$ where $x$ represents the number of nodes of that particular tree. In this section, we will use this result to test experimentally that the amortized complexity of $(n-1)$ calls of \textbf{inorder\_next} correspond to $2(x-1)$.

\bigskip

To do this task, we need to consider the following information:
\begin{itemize}
  \item First, the amortized complexity is an upper bound on total actual complexity. \textit{This means that the amortized complexity is always bigger or equal than the total actual complexity}
  \item Second, the operation of traverse an entire binary tree with $n$ nodes is exactly the same than call the \textbf{inorder\_next} function $n$ times
  \item Third, if we do $n$ calls to a function the actual complexity of this operation will always be bigger or equal than the actual complexity of $n-1$ calls to the same function
\end{itemize}

\bigskip
\bigskip

Using the above information and also considering the results obtained in the last section, we can state the following:
\begin{itemize}
  \item The actual complexity for $n$ calls of \textbf{inorder\_next } can be represented by the equation $2(x-1)$. \textit{where $x$ represents the number of nodes in a binary tree}
  \item Considering that $n-1$ calls to a function is les expensive than $n$ calls in the same function (in terms of complexity), we can state than \textbf{$2(x-1)$ is an upper bound of the actual complexity of $n-1$ calls}. \textit{This state is based in the fact that $2(x-1)$ will always be bigger or equal than the actual complexity of $n-1$ calls}
  \item Finally as $2(x-1)$ is an upper bound of the actual complexity of $n-1$ calls to the function \textbf{inorder\_next}, we can also said that $2(x-1)$ \textbf{is a possible value for the amortized complexity of this function}
\end{itemize}

\bigskip

In conclusion, by collecting data and using the method shown in this paper, we managed to test experimentally that $2(x-1)$ or $2x-2$ is a totally possible value for the amortized complexity of $n-1$ calls of the \textbf{inorder\_next} function.


%----------------------------------------------------------------------------------------
%				(5) Appendices
%----------------------------------------------------------------------------------------

   \newpage 				% Creates a new page

  \section{Appendices}

  \subsection{Python code used for Task1}

%  Define color for including python code in PDF
  \definecolor{keywords}{RGB}{255,0,90}
  \definecolor{comments}{RGB}{0,0,113}
  \definecolor{red}{RGB}{160,0,0}
  \definecolor{green}{RGB}{0,150,0}
 
\lstset{language=Python, 
        basicstyle=\ttfamily\small, 
        keywordstyle=\color{keywords},
        commentstyle=\color{comments},
        stringstyle=\color{red},
        showstringspaces=false,
        identifierstyle=\color{green},
        procnamekeys={def,class}}
 
\begin{lstlisting}

"""
-------------------------------------
HEADER OF THE PROGRAM
-------------------------------------
"""

# Import Section of the code 
import random

# Constants definition section
LOWER_SIZE_BOUND = 50
UPPER_SIZE_BOUND = 100
RANDOM_TREES = 50
Id = 0
n = 0

"""
-------------------------------------
BINARY NODE CLASS DEFINITION 
-------------------------------------
"""

# Class that creates a node of a binary tree
class binary_node()	:
    # Sets the initial configuration for a binary tree
	def __init__(self):
        # A new binary tree has no left or right Child
		global Id
		Id = Id + 1
		self.Id = Id
		self.leftChild = None
		self.rightChild = None

	# Returns the left Child node
	def get_lChild(self):
		return self.leftChild

	# Returns the right Child node
	def get_rChild(self):
		return self.rightChild

	# Creates a new left Child node
	def create_lChild(self, nodes, leftChildAbleNode, rightChildAbleNode
	, index):
		self.leftChild = binary_node()
		nodes.append(self.leftChild)
		del (leftChildAbleNode[index])
		leftChildAbleNode.append(self.leftChild)
		rightChildAbleNode.append(self.leftChild)
		return self.leftChild

	# Creates a new right Child node
	def create_rChild(self, nodes, leftChildAbleNode, rightChildAbleNode
	, index):
		self.rightChild = binary_node()
		nodes.append(self.rightChild)
		del (rightChildAbleNode[index])
		leftChildAbleNode.append(self.rightChild)
		rightChildAbleNode.append(self.rightChild)
		return self.rightChild


"""
-------------------------------------
BINARY TREE CLASS DEFINITION 
-------------------------------------
"""

# Class that creates a random binary tree
class random_binary_tree():

	def __init__(self):
		self.nodes = self.create_randomTree()
		self.total = 0
		self.total_first = 0

	def create_randomTree(self):
		# We create and empty list with every node, one with the left child 
		# capables and other with the right child capables
		nodes = []
		leftChildAbleNode= []
		rightChildAbleNode= []
		index = 0

		# Generates a random number between 50 and 100 for the size of tree
		treeNodesMax = random.randint(LOWER_SIZE_BOUND,UPPER_SIZE_BOUND)

		# First, we need to create the root of the tree
		root = binary_node()

		# We add the root to the nodes list
		nodes.append(root)
		leftChildAbleNode.append(root)
		rightChildAbleNode.append(root)

		while len(nodes) < treeNodesMax:

			# If the flag is 0, then a new left child will be created
			 else a new right child will be created
			leftRightFlag = random.randint(0,1)

			# Choose a random Node from the correspondent list
			if leftRightFlag == 0:
				index = random.randint(0,len(leftChildAbleNode)-1)
				leftChildAbleNode[index].create_lChild
				(nodes, leftChildAbleNode, rightChildAbleNode
				, index)
			elif leftRightFlag == 1:
				index = random.randint(0,len(rightChildAbleNode)-1)
				rightChildAbleNode[index].create_rChild
				(nodes, leftChildAbleNode, rightChildAbleNode
				, index)

		return nodes

		
	# Return the list with nodes of the random Tree
	def get_nodes(self):
		return self.nodes

	# Transverse the binary tree using recursion
	def transverse(self, rootNode):
		if rootNode is not None:
			if rootNode.get_lChild() is not None:
				self.total = self.total + 1					# We add 1 step for every left child visited
				self.transverse(rootNode.get_lChild())
				self.total = self.total + 1 				# We add 1 step for going back to root
			if rootNode.get_rChild() is not None:
				self.total = self.total + 1 				# We add 1 step for every right child visited (1 for visiting the root and 1 for going right
				self.transverse(rootNode.get_rChild())
				self.total = self.total + 1 				# We add 1 step for going back to root
		return None

"""
-------------------------------------
	MAIN PROGRAM 
-------------------------------------
"""

# Creates a list of random trees
randomTrees = []

# Creates 50 Random Trees
while len(randomTrees) < RANDOM_TREES:
	tree = random_binary_tree()
	randomTrees.append(tree)


# Open file for writing the results in CSV format
f = open("Output.txt", "w")
f.write("RANDOM TREE ID;NUMBER OF NODES IN TREE;
	TOTAL COST OF INORDER_NEXT OPERATION\n")

# Prints the whole tree structure
for tree in randomTrees:
	n = n + 1
	tree.transverse(tree.get_nodes()[0])

	inorderNext_Cost = tree.total

	f.write("%d;%d;%d\n" % (n,len(tree.get_nodes()),inorderNext_Cost))

	print("\n		TREE N°%d" % n)
	print("===================================================")
	print("NUMBER OF NODES IN TREE: %d  NODES" % len(tree.get_nodes()))
	print("TOTAL COST OF INORDER_NEXT: %d  STEPS" % inorderNext_Cost)
	print("===================================================")	

f.close()
\end{lstlisting}
 
\bigskip

  \subsection{Github URL for python code}
https://github.com/JokerswildX/T1HSK

%----------------------------------------------------------------------------------------
%				PAGE 14:  	TASK 2
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
%				Title section
%----------------------------------------------------------------------------------------

  \chapter{Preassignment - Task 2}			% Subsection of a document

%----------------------------------------------------------------------------------------
%				(1) First section
%----------------------------------------------------------------------------------------
 
  \section{Introduction}			% Subsection of a document

%   First Paragraph
  \large The second task of the preassignment consists of making an estimation of the amortized analisis of $m1$ calls to push($x$) and $m2$ calls to pop($k$) in a stack data structure. It is important to remember that applying the push($x$) function to a stack, pushes an item $x$ onto the top of that particular stack. In contrast, applying the pop($k$) function to a stack allows us to pop out $k$ entries of the stack at once. 

\bigskip

The strategy followed to solve this task is described in detail in the following section.

%----------------------------------------------------------------------------------------
%				(2) Second section
%----------------------------------------------------------------------------------------
 
  \section{Materials and Methods}			% Subsection of a document

To solve this task, we decide to use the known paradigm of "divide and conquer". 

\bigskip

We already know that the amortized complexity of a whole operation is the sum of the amortized complexities of its stages. Therefore, instead of estimating the total amortized complexity of $m1$ calls to push($x$) and $m2$ calls to pop($k$) we will estimate 2 different amortized complexities:
\begin{itemize}
 \item Amortized Complexity of call push($x$)
 \item Amortized Complexity of call pop($k$)
\end{itemize}

\bigskip

For estimating the above complexities we also need to consider the following equation:

\begin{center}
\Large
$a_{i} = t_{i} + \Phi(S_{i}) - \Phi(S_{i-1}) $
\end{center}

\large

\textit{Where $a_{i}$ represents the amortized complexity of the $i$th call, $t_{i}$ represents the actual worst case complexity of the $i$th call}, $\Phi(S_{i})$ represents the potencial function of the $i$th call and $\Phi(S_{i-1})$ the potencial function of the $(i-1)$th call

\bigskip

In addition to the above equation, we also need to choose a right potencial function ($\Phi(S)$) so that $\Phi(S_{i}) \geq \Phi(S_{i-1})$. This behaviour allows the amortized complexity to work as an upper bound of the total actual complexity of the operation. In the next section, we will use all the above information to estimate the amortized complexity of the sequence of push($x$) and pop($k$) in the stack.


%----------------------------------------------------------------------------------------
%				(3) Third section
%----------------------------------------------------------------------------------------
 
  \section{Results}			% Subsection of a document

First of all, as we seen in the last section, before even begun estimating the amortized complexity of the sequence of pop and push calls, we need to first choose a right potencial function. \textbf{In this particular case, we decide to choose the potencial function $\Phi(S_{i})$ to be the current number of items in the stack}. This chosen potencial function seems to be adequate as the bigger the number of elements in the stack, the more steps, potencially the operation must do in order to reach the next state. Also, considering that the initial state of the stack is empty, after $n$ operations we know that $\Phi(S_{n}) \geq \Phi(S_{0})$ as no negative index are allowed into a stack.

\bigskip

Having decided the potencial function $\Phi(S)$, the next task is to estimate the amortized complexity for the both considered cases, the $m1$ calls to push($x$) and the $m2$ calls to pop($k$). Let's begin with the $m1$ calls to push($x$):

\bigskip

\begin{enumerate}
\item \underline{$m1$ calls to push($x$)}:

Let's start by estimating the push($x$) amortized complexity. If the $i$th call in the stack is a push($x$) and the stack has $s$ elements in it, we have the following estimation:

\Large
\begin{align}
\nonumber
a_{i} &= t_{i} + \Phi(S_{i}) - \Phi(S_{i-1}) \\
\nonumber
a_{i} &= 1 + (s+1) - (s) \\
\nonumber
a_{i} &= 2 \\
\nonumber
\end{align}

\large
So we can conclude that $m1$ calls to push($x$) has an amortized complexity of $2\cdot(m1)$. Let's now examine the case of the $m2$ calls of pop($k$).

\bigskip

\item \underline{$m2$ calls to pop($k$)}:
\end{enumerate}

For estimating the pop($k$) amortized complexity, we will consider that the $i$th call in the stack is a pop($k$) operation and that the stack has a initial state with $s$ elements in it. In this case, we have the following estimation:

\Large
\begin{align}
\nonumber
a_{i} &= t_{i} + \Phi(S_{i}) - \Phi(S_{i-1}) \\
\nonumber
a_{i} &= min(k,s) + (s- min(k,s)) - s \\
\nonumber
a_{i} &= 0 \\
\nonumber
\end{align}

\large
The value $min(k,s)$ represents the minimum value between the number $k$ and $s$. We need to consider this value because the minimum value between $k$ \textit{(number of elements that we are trying to pop out of the stack)} and $s$ \textit{(the total amount of elements in the stack)} will be the maximum possible value to pop out of the stack for the case described above. Considering the above result, we can conclude that $m2$ calls to pop($k$) has an amortized complexity of 0. 

\bigskip

Considering the results of the $m1$ calls to push($x$) and the $m2$ calls to pop($k$) and also considering that the total amortized complexity is the sum of its stages, we can conclude that the total amortized complexity of $m1$ calls to push($x$) and the $m2$ calls to pop($k$) is $2\cdot(m1)$. The maximum value that $2\cdot(m1)$ can take is $n$ where $n$ is the maximal size of the stack. \textbf{Therefore we can conclude that the amortized analysis of the sequence is O(n)}.


%----------------------------------------------------------------------------------------
%				(4) Forth section
%----------------------------------------------------------------------------------------
 
  \section{Discusion}			% Subsection of a document

When comparing the result of the amortized complexity analysis obtained in section 3 ( complexity O($n$) ) with the result of the worst case complexity analysis ( complexity O($n^2$) ), we can infer the following conclusions:

\begin{itemize}
   \item The worst case complexity analysis is much more pessimistic than the amortized complexity analysis
   \item Certainly, the amortized analysis is more accurate than the worst case complexity analysis, however, define an adequate potential function can be really challenging in some specific cases (requires some previous experience)
   \item Considering the fact that choosing a potential function can be sometimes challenging, estimating an amortized complexity can take more time than estimating the worst case complexity
\end{itemize}

In conclusion, the amortized complexity analysis is a very helpful and also more precise method for estimating an algorithm complexity than the worst case complexity method. However, in some cases could be a little more challenging to estimate,  therefore I strongly recommend to consider the final goal of the complexity estimation before deciding which method its better to use in a particular case.

\end{document}